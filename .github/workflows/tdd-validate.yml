name: TDD Queue - Validate

on:
  # Trigger on push to spec branches
  push:
    branches:
      - 'tdd/spec-*'

# Security: Define minimal required permissions
permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

# Allow concurrent validation (different specs can validate in parallel)
concurrency:
  group: tdd-validate-${{ github.ref }}
  cancel-in-progress: true

env:
  BUN_VERSION: '1.3.1'
  NODE_VERSION: '20'

jobs:
  validate:
    name: üß™ Validate Spec Implementation
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Install Playwright browsers
        run: bunx playwright install --with-deps chromium

      - name: Extract spec ID from branch
        id: spec
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          SPEC_ID=$(echo "$BRANCH_NAME" | sed 's/tdd\/spec-//')
          echo "spec_id=$SPEC_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Spec ID: $SPEC_ID"

      - name: Find issue for spec
        id: issue
        run: |
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          echo "üîç Finding issue for spec: $SPEC_ID"

          # Search for issue with spec ID in title
          ISSUE_JSON=$(gh issue list \
            --label "tdd-spec" \
            --search "$SPEC_ID" \
            --json number,title \
            --limit 1)

          ISSUE_NUMBER=$(echo "$ISSUE_JSON" | jq -r '.[0].number')

          if [ "$ISSUE_NUMBER" == "null" ] || [ -z "$ISSUE_NUMBER" ]; then
            echo "‚ùå No issue found for spec $SPEC_ID"
            echo "has_issue=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found issue #$ISSUE_NUMBER"
            echo "has_issue=true" >> $GITHUB_OUTPUT
            echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Find test file for spec
        id: test_file
        run: |
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          echo "üîç Finding test file for spec: $SPEC_ID"

          # Search for test file containing the spec ID
          TEST_FILE=$(grep -rl "$SPEC_ID" specs/ | grep "\.spec\.ts$" | head -1)

          if [ -z "$TEST_FILE" ]; then
            echo "‚ùå No test file found for spec $SPEC_ID"
            echo "has_test_file=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Found test file: $TEST_FILE"
            echo "has_test_file=true" >> $GITHUB_OUTPUT
            echo "test_file=$TEST_FILE" >> $GITHUB_OUTPUT
          fi

      - name: Run spec test
        id: spec_test
        if: steps.test_file.outputs.has_test_file == 'true'
        run: |
          TEST_FILE="${{ steps.test_file.outputs.test_file }}"
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"

          echo "üß™ Running spec test: $SPEC_ID"

          # Run only the specific spec (use grep to filter)
          if CLAUDECODE=1 bun test:e2e "$TEST_FILE" --grep "$SPEC_ID"; then
            echo "spec_pass=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Spec test passed"
          else
            echo "spec_pass=false" >> $GITHUB_OUTPUT
            echo "‚ùå Spec test failed"
          fi

      - name: Run regression tests
        id: regression
        if: steps.spec_test.outputs.spec_pass == 'true'
        run: |
          echo "üß™ Running regression tests..."

          if CLAUDECODE=1 bun test:e2e:regression; then
            echo "regression_pass=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Regression tests passed"
          else
            echo "regression_pass=false" >> $GITHUB_OUTPUT
            echo "‚ùå Regression tests failed"
          fi

      - name: Run code quality checks
        id: quality
        if: steps.regression.outputs.regression_pass == 'true'
        run: |
          echo "üîç Running code quality checks..."

          # License headers
          if bun run license; then
            LICENSE_PASS=true
          else
            LICENSE_PASS=false
          fi

          # Lint
          if bun run lint; then
            LINT_PASS=true
          else
            LINT_PASS=false
          fi

          # Type check
          if bun run typecheck; then
            TYPECHECK_PASS=true
          else
            TYPECHECK_PASS=false
          fi

          # All checks must pass
          if [ "$LICENSE_PASS" = true ] && [ "$LINT_PASS" = true ] && [ "$TYPECHECK_PASS" = true ]; then
            echo "quality_pass=true" >> $GITHUB_OUTPUT
            echo "‚úÖ All quality checks passed"
          else
            echo "quality_pass=false" >> $GITHUB_OUTPUT
            echo "‚ùå Some quality checks failed"
            echo "  License: $LICENSE_PASS"
            echo "  Lint: $LINT_PASS"
            echo "  Typecheck: $TYPECHECK_PASS"
          fi

      - name: Generate and commit roadmap
        id: roadmap
        if: steps.quality.outputs.quality_pass == 'true'
        run: |
          echo "üìä Generating updated roadmap..."

          # Generate roadmap
          if bun run generate:roadmap; then
            echo "‚úÖ Roadmap generated successfully"

            # Check if roadmap changed
            if ! git diff --quiet ROADMAP.md; then
              echo "üìù Roadmap has changes, committing..."

              # Configure git
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"

              # Commit and push
              git add ROADMAP.md
              git commit -m "docs: update roadmap after spec implementation"
              git push

              echo "‚úÖ Roadmap committed and pushed"
              echo "roadmap_updated=true" >> $GITHUB_OUTPUT
            else
              echo "‚ÑπÔ∏è  No changes to roadmap"
              echo "roadmap_updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  Roadmap generation failed (non-blocking)"
            echo "roadmap_updated=false" >> $GITHUB_OUTPUT
          fi

      - name: Check overall result
        id: result
        if: always()
        run: |
          SPEC_PASS="${{ steps.spec_test.outputs.spec_pass }}"
          REGRESSION_PASS="${{ steps.regression.outputs.regression_pass }}"
          QUALITY_PASS="${{ steps.quality.outputs.quality_pass }}"

          if [ "$SPEC_PASS" = "true" ] && [ "$REGRESSION_PASS" = "true" ] && [ "$QUALITY_PASS" = "true" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "‚úÖ All validation passed"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "‚ùå Validation failed"
          fi

      - name: Mark spec as completed (on success)
        if: steps.result.outputs.success == 'true' && steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          ROADMAP_UPDATED="${{ steps.roadmap.outputs.roadmap_updated }}"

          echo "‚úÖ Marking spec as completed..."

          # Update labels
          gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"
          gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:completed"

          # Close issue
          gh issue close "$ISSUE_NUMBER" --reason completed

          # Build success message with roadmap status
          MESSAGE="‚úÖ **Validation passed**

          All tests and quality checks passed successfully!

          - ‚úÖ Spec test passed
          - ‚úÖ Regression tests passed
          - ‚úÖ Code quality checks passed"

          if [ "$ROADMAP_UPDATED" = "true" ]; then
            MESSAGE="${MESSAGE}
          - üìä Roadmap updated and committed"
          fi

          MESSAGE="${MESSAGE}

          Spec $SPEC_ID is now completed. This issue is closed."

          # Add success comment
          gh issue comment "$ISSUE_NUMBER" --body "$MESSAGE"

          echo "‚úÖ Issue #$ISSUE_NUMBER marked as completed"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Enable auto-merge (on success)
        if: steps.result.outputs.success == 'true'
        run: |
          echo "üîÄ Enabling auto-merge for PR..."

          # Find PR for current branch
          BRANCH_NAME="${{ github.ref_name }}"
          PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number')

          if [ ! -z "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            # Mark PR as ready
            gh pr ready "$PR_NUMBER"

            # Enable auto-merge
            gh pr merge "$PR_NUMBER" --auto --squash

            echo "‚úÖ Auto-merge enabled for PR #$PR_NUMBER"
          else
            echo "‚ö†Ô∏è  No PR found for branch $BRANCH_NAME"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Comment failure on issue
        if: steps.result.outputs.success != 'true' && steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"

          SPEC_PASS="${{ steps.spec_test.outputs.spec_pass }}"
          REGRESSION_PASS="${{ steps.regression.outputs.regression_pass }}"
          QUALITY_PASS="${{ steps.quality.outputs.quality_pass }}"

          echo "‚ùå Commenting failure on issue..."

          # Build failure message
          MESSAGE="‚ùå **Validation failed**

          "

          if [ "$SPEC_PASS" != "true" ]; then
            MESSAGE="${MESSAGE}- ‚ùå Spec test failed\n"
          else
            MESSAGE="${MESSAGE}- ‚úÖ Spec test passed\n"
          fi

          if [ "$REGRESSION_PASS" != "true" ]; then
            MESSAGE="${MESSAGE}- ‚ùå Regression tests failed\n"
          else
            MESSAGE="${MESSAGE}- ‚úÖ Regression tests passed\n"
          fi

          if [ "$QUALITY_PASS" != "true" ]; then
            MESSAGE="${MESSAGE}- ‚ùå Code quality checks failed\n"
          else
            MESSAGE="${MESSAGE}- ‚úÖ Code quality checks passed\n"
          fi

          MESSAGE="${MESSAGE}
          Please review the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details, fix the implementation, and push again."

          gh issue comment "$ISSUE_NUMBER" --body "$MESSAGE"

          echo "‚úÖ Failure comment added to issue #$ISSUE_NUMBER"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Handle validation failure with retry
        if: steps.result.outputs.success != 'true' && steps.issue.outputs.has_issue == 'true'
        run: |
          ISSUE_NUMBER="${{ steps.issue.outputs.issue_number }}"
          SPEC_ID="${{ steps.spec.outputs.spec_id }}"
          MAX_RETRIES=3

          echo "üîÑ Handling validation failure for spec $SPEC_ID..."

          # Get current retry count from labels
          LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' || echo "")
          CURRENT_RETRY=$(echo "$LABELS" | grep -oP 'retry:\K\d+' | head -1 || echo "0")
          NEXT_RETRY=$((CURRENT_RETRY + 1))

          echo "Current retry: $CURRENT_RETRY"
          echo "Next retry: $NEXT_RETRY"

          if [ "$NEXT_RETRY" -le "$MAX_RETRIES" ]; then
            echo "üìù Retry $NEXT_RETRY/$MAX_RETRIES - Re-queueing spec..."

            # Remove old retry label if exists
            if [ "$CURRENT_RETRY" -gt 0 ]; then
              gh issue edit "$ISSUE_NUMBER" --remove-label "retry:$CURRENT_RETRY" || true
            fi

            # Add new retry label and re-queue
            gh issue edit "$ISSUE_NUMBER" --add-label "retry:$NEXT_RETRY"
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"
            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:queued"

            # Add retry comment
            gh issue comment "$ISSUE_NUMBER" --body "üîÑ **Retry $NEXT_RETRY/$MAX_RETRIES**

          Validation failed. Spec has been automatically re-queued for another attempt.

          The queue will continue processing other specs while this one waits for retry."

            echo "‚úÖ Re-queued with retry label: retry:$NEXT_RETRY"
          else
            echo "‚ùå Max retries ($MAX_RETRIES) exceeded - Marking as failed"

            # Remove retry label
            gh issue edit "$ISSUE_NUMBER" --remove-label "retry:$CURRENT_RETRY" || true

            # Mark as permanently failed
            gh issue edit "$ISSUE_NUMBER" --remove-label "tdd-spec:in-progress"
            gh issue edit "$ISSUE_NUMBER" --add-label "tdd-spec:failed"

            # Add final failure comment
            gh issue comment "$ISSUE_NUMBER" --body "‚ùå **Maximum retries exceeded**

          This spec failed validation after $MAX_RETRIES attempts and has been marked as \`failed\`.

          **Manual intervention required**:
          1. Review the implementation complexity
          2. Consider adding \`skip-automated\` label if too complex for automation
          3. Or manually implement and push to the branch

          **The queue will continue processing other specs** - this failure does not block the pipeline."

            echo "‚úÖ Marked as failed (max retries exceeded)"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ steps.spec.outputs.spec_id }}
          path: |
            playwright-report/
            test-results/
          retention-days: 7
